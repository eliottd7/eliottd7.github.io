<!DOCTYPE html>
<head>
    <style>
        @media screen and (min-width: 200px) {
            body {
                background-color: black;
                width: 90vw;
                height: 90vh;
                border: black;
            }

            div#main {
                font-size: 3vw;
            }
        }
    </style>
</head>
<body>
    <div id="main">
        <canvas id="main_board"></canvas>
    </div>
<script>

    const canvas = document.getElementById("main_board");
    field = document.getElementById("main_board").getContext('2d')

    // resize the canvas to fill browser window dynamically
    window.addEventListener('resize', resizeCanvas, false);
    
    function resizeCanvas() {
        canvas.width = 0.98*window.innerWidth;
        canvas.height = 0.98*window.innerHeight;
        csize = 0.95 * Math.min(window.innerWidth, window.innerHeight)
    }

    resizeCanvas();

    particle_size = 1.5
    velocity_cap = 2

    draw = (x, y, color, s) => {
        field.fillStyle = color
        field.fillRect(x, y, s, s)
    }

    particles = []
    particle = (x, y, color, border_type) => {
        return {
            "x":x,
            "y":y,
            "vx":0,
            "vy":0,
            "color":color,
            "border":border_type
        }
    }

    random = () => {
        return Math.random() * csize * 0.99
    }

    create = (number, color, border) => {
        group = []
        for (let i = 0; i < number; i++){
            group.push(particle(random(), random(), color, border))
            particles.push(group[i])
        }
        return group
    }

    rule = (part1, part2, g) => {
        for(let i = 0; i < part1.length; i++){
            fx = 0
            fy = 0

            for(let j = 0; j < part2.length; j++){
                a = part1[i]
                b = part2[j]

                dx = a.x - b.x
                dy = a.y - b.y
                d = Math.sqrt(dx * dx + dy * dy)

                if (d > 0) {
                    F = g * 1 / d
                    fx += (F * dx)
                    fy += (F * dy)
                }

                a.vx = (a.vx + fx)
                a.vy = (a.vy + fy)

                if(a.vx > velocity_cap) a.vx = velocity_cap
                else if(a.vx < 0-velocity_cap) a.vx = 0-velocity_cap

                if(a.vy > velocity_cap) a.vy = velocity_cap
                else if(a.vy < 0-velocity_cap) a.vy = 0-velocity_cap

                a.x += a.vx
                a.y += a.vy

                if(a.border){
                    if (a.x > csize){
                        a.x = csize - 1
                        a.vx = -a.vx
                    } 
                    else if (a.x < 0) {
                        a.x = 0
                        a.vx = -a.vx
                    }
                    if (a.y > csize){
                        a.y = csize - 1
                        a.vy = -a.vy
                    }
                    else if (a.y < 0) {
                        a.y = 0
                        a.vy = -a.vy
                    }

                } else {
                    if (a.x > csize) a.x = 0
                    else if (a.x < 0) a.x = csize
                    if (a.y > csize) a.y = 0
                    else if (a.y < 0) a.y = csize
                }
            }
        }
    }

    update = () => {
        rule(yellow, gravity, -0.1)
        rule(yellow, yellow, -0.001)
        rule(green, yellow, -0.004)
        rule(green, gravity, -0.001)

        field.clearRect(0, 0, csize + 1, csize + 1)
        draw(0, 0, "black", csize)

        for(i = 0; i < particles.length; i++){
            draw(particles[i].x, particles[i].y, particles[i].color, particle_size)
        }
        requestAnimationFrame(update)

    }

    // color = black if "hidden"
    green = create(20000, "green", false)
    yellow = create(3, "yellow", false)
    gravity = [particle(csize/2, csize/2, "black", false)]
    update();

    

</script>
</body>